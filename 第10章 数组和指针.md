1. 数组初始化:
C90: int power[8] = {1, 2, 3, 4, 5, 6, 7, 8}
自动存储类数组若不初始化， 则值不确定， 若不完全赋值， 则其余值均为0。
sizeof(power)返回power数组对象的大小32Byte。
C99：int arr[6] = { [5] = 212}， 即允许随意指定元素初始化。
C不支持把数组作为一个整体来赋值， 也不支持用花括号括起来进行赋值。
如:int a[5], b[5] ;  a = b ; a[5] = b[5] ; a[5] = {1, 2, 3, 4, 5}。

2. 为了不减慢运行速度， C不进行数组越界检查。
数组大小：C99允许变长数组即动态生成， int  a[m][n] or int[*][*] ;
一般多维数组声明允许省略第一位大小：
int  ar[][12][12][12]  等价于    int (*ar)[12][12][12]。[]优先级高， 不加括号， 则ar为数组， 数组的元素为指针。
初始化二维数组：int a[2][2] = { {1, 2}, {1, 2} } ; 里面的括号可省去。

3. 指针和数组
int a[5] ;   a == &a[0] 输出指针用%p
a在C 中指针加1的结果是对该指针增加一个该指针指向数据对象存储长度。
注意sizeof(a) == 4*5Byte  sizeof(&a[0]) == 4Byte
sizeof返回一个对象或者类型所占的内存字节数。a虽然是指针，但它代表数组对象。
在函数原型和函数定义头中， 可以用int* a 代替 int a[]。但此时的a只具有指针性质，即sizeof(a) ==  4。
指针符号更符合机器语言， 所以可编译生成更高效的代码。
指针可执行的基本操作：
赋值：c99允许指针赋值双方所指数据类型不一致 ；数组名不能赋值
求值或取值：* ；
取指针地址：& ；
将一个整数加给指针：pt + 3 ；
增加指针的值：pt + 1 or pt++  ；
从指针中减去一个整数：pt – 3 ；
减小指针的值：pt-- ;
求差值：pt2 – pt1 ；

4. 保护数组
const int a[10] ；----a是指向常量的常量指针。
将指向常量或非常量数据的指针赋给指向常量的指针是合法的。
但是把指向非常量的指针赋给指向常量的指针只能进行一层间接运算。
int * p1 ; const int ** p2 ;---------p2, *p2均为指向const数据指针。
p2 = &p1 ; 则不合法。
不然const int n = 10 ; *p2 = &n ; *p1 =10; 改变了n。
数组名是指针常量。
指向常量数据的指针不能赋给指向非常量的指针， 否则会通过指向非常量的指针改变常量值。
const int * const a ；------指向常量数据的常量指针。

5. 指针和多维数组
int a[20][10] ;
 &a ==a == &a[0] == a[0] == (&a[0][0]) ;
由于a, a[0]均为数组， C规定数组的地址就是数组名的值。把a要理解成数组名。
a = &a[0]  a[0] = &a[0][0]
*(*(a+2)+1)数组第3行第2列。

6. 复合文字
(int [2]) {10, 20}  or  (int[]) {10, 20}
Int * a ;
a = (int []) {10, 20} ;或作为函数实际参数。