1. 和文件进行通信：
一种简单方式就是文件重定向----------test < input > output
C提供了更强大的文件通信方法，可以在程序中打开文件，然后使用专门的I/O函数读写文件。
C90提供二种文件视图：文本视图和二进制视图
在二进制视图中， 文件中的每个字节均可见。在文本视图中可能不同， 会把文件内容从具体系统的文本表示法映射到C表示法。
如：MS_DOS中文本文件换行\r\n, 文件结束^z----------文本视图中\r\n—>\n, ^z没有。但由于Unix仅采用一种文件结构， 所以二种视图打开是相同的。
低级I/O使用操作系统提供的基本I/O服务；标准高级I/O使用一个标准的C库函数包和stdio.h头文件中的定义。
C程序自动打开3个标准文件（文件指针）：stdin, stdout, stderr---------getchar(), gets(), scanf()读取文件， putchar(), puts(), printf()写入文件。

2. 标准I/O
相对于低级I/O的优势：1)标准I/O包中包含许多专用的函数，可以方便地处理不同的I/O问题；2)对输入输出进行了缓冲。
exit(1 or 0)-------关闭所有打开的文件并终止文件参数传递给操作系统， 0（EXIT_SUCCESS）正常终止， 1(EXIT_FAILURE)非正常终止。
与return  0不同的是：1）exit（0）在一个递归程序中仍然会终止程序，return会将控制权交给上一级；2）在非main（）函数中exit（0）仍终止程序。
FILE* fopen(char* name， char* format)---------
返回文件指针FILE*，FILE是stdio.h定义的一种结构类型， FILE*指向一个关于文件的信息的数据包（包括缓冲区信息）。
不能打开返回NULL-----磁盘满、文件名非法、存取权限不够或者硬件问题。
“r”: 打开文本文件， 可以读取文件。
“w”: 打开文本文件， 写文件。文件长度截为0， 不存在则创建文件。
“a”: 与上不同的是， 追加文件尾部。
“r+”: 读写都可以, 文件必须存在
“w+”: 读写都可以， 文件存在时将文件长度截为0， 否则创建文件。
“a+”: 与上不同的是， 追加文件尾部。
以上加b都以二进制模式打开。
int fclose(FILE*)----------关闭指定的文件， 同时根据需要刷新缓冲区。成功返回0， 失败返回EOF（-1）。---------磁盘已满、磁盘被移走、出现I/O错误。

3. 文件I/O
1) int getc(FILE*), void putc(char, FILE*)
getchar(), putchar(char)均由上述和标准文件指针实现。
文件结束------getc（FILE*）返回EOF, 但是也可能是因为读取错误。
int feof(FILE*)----------如果最后一次输入调用检测到文件结尾返回一个非零值， 否则返回零值；
int ferror(FILE*)-----------发生读取错误返回非零值， 否则返回零值。
2) int fprintf(FILE*, char* format, ….), int fscanf(FILE*, char* format, ….)
与scanf（）， printf（）类似。注意FILE*在第一个参数。
rewind(FILE*)使程序回到文件开始处。
3) fgets(char*, int, FILE*), fputs(char*, FILE*)
fgets()读取n-1个字符或者读取完’\n’， 然后追加一个空字符。gets()读取’\n’但不放入缓冲区并丢弃。
fputs()输入不添加换行符， puts()添加’\n’。
---------屏幕（输出）缓冲区：直到遇到换行符，才把输出发送到屏幕。
4) 二进制I/O----------把数据存储在一个使用与程序具有相同表示法的文件中，称数据以二进制方式存储。这中间没有数字形式到字符串形式的转换。
-------因为C将每个字节看做一个字符编码， fscanf， scanf尝试把字符编码翻译成格式指定的其他类型。----相当于atoi
size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp) ;
------使用这一函数来读取fwrite写进的数据。
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp) ;
--------二进制数据写入文件 ptr是要写入数据块地址， size数据块的字节数， nmemb数据块数目， fp指定流。
C90规定void*作为普通指针， 之前用char* 实际参数要类型指配。
double earnings[10] ;
fwrite(earnings, sizeof(double), 10, fp) ;
fread(earnings, sizeof(double), 10, fp) ;
返回读取写入项目数。
5) 随机存取：----------二进制文件下更适合
int fseek(FILE*, long, int)---------第二个参数表示偏移量， 第三个参数表示模式。
long可正（向前移动）可负（向后移动）。
模式：SEEK_SET（0L文件开始）， SEEK_CUR（1L当前位置）， SEEK_END（2L文件结尾）。
正常返回0， 出错返回-1
long ftell（FILE*）---------返回文件当前位置（距文件开始处字节数目， 第一个字节返回0， 文件结尾处返回的正好是字节个数）。
---------ftell在文本模式和二进制模式下地工作方式有所不同，因为很多系统的文本文件格式都与UNIX不同。C90规定， ftell()返回一个可用作fseek()第二个参数的值。
理论上，fseek（）和ftell（）应该符合Unix模型， 但实际系统有差异， 所以C90降低了对这些函数的要求。
上述函数只能处理long类型范围大小文件----------大文件用：
int fgetpos(FILE* restrict stream, fpos_t* restrict pos) ;
int fsetpos(FILE* stream, const fpos_t* pos) ;
fpos_t类型的变量或数据对象用来指定文件的位置， 不能是数组类型。

4.标准I/O内幕
1) fopen（）打开一个文件， 建立一个缓冲区（读写模式下建立2个），还创建了一个包含文件和缓冲区相关数据的数据结构，返回一个指向该结构的指针；
这个数据结构包括：文件位置指示器， 错误指示器， 文件结尾指示器， 一个指向缓冲区起始处的指针， 文件标识符， 记录实际复制到缓冲区的字节数的计数器。
2) 文件输入：调用stdio.h头文件中声明的某个输入函数，会把一块数据从文件复制到缓冲区（缓冲区通常是512或者它的倍数）。第一次调用输入函数，除了填充缓冲区， 还将设置fp所指结构的值（特别的是流的当前位置和复制到缓冲区的字节数）。
数据结构和缓冲区初始化后，输入函数将从缓冲区中读取所请求的数据， 同时文件位置指示器为下一个字符位置， 因为输入函数共享同一个缓冲区，下一个输入函数将从当前位置读取。
当输入函数检测到到已经读取了缓冲区里的全部字符， 它就会请求系统将下一块缓冲区大小的数据复制到缓冲区。
函数在读入最后一缓冲区的最后一个字符后， 会将文件结尾指示器置真。于是下一个输入函数将返回EOF。
输出函数将数据写入缓冲区， 缓冲区满时， 就将数据写入文件。

5. 其他标准I/O函数
1) int ungetc(int c, FILE* fp)------------指定字符放回到输入流中。
C90规定每次只放回一个字符。
2) int fflush(FILE*)--------刷新缓冲区
调用可以将缓冲区中任何未写的数据发送到指定的输出文件中。fp为NULL则将刷新所有缓冲区。对输入流没定义， VC中定义了。
3) int setvbuf(FILE* restrict fp, char* restrict buf, int mode, size_t size) ;
setvbuf()建立一个供标准I/O函数使用的存储区， 打开文件后， 在没有对流进行任何操作之前， 可以调用这个函数。
fp指定流， buf指向将要使用的缓冲区， NULL则系统会自动创建一个缓冲区， size是缓冲区buf大小， mod--------_IOFBF完全缓冲，_IOLBF行缓冲， _IONBF无缓冲。
成功返回0， 否则返回非0值。

6. 控制台
getchar()-------stdio.h中的库函数，从stdio流中读取一个字符
getch(), getche()------conio.h中的库函数， 从键盘接收字符
实际上是输入设备--内存缓冲区----程序getchar
getchar,scanf是回车（’\r’）以后再进入缓冲区取数据的（可看做把一行数据才送入缓冲区），getch立刻回显
但输出缓冲区发送到屏幕-------------
标准C规定：缓冲区满；遇到换行符， 等到键盘输入（或者程序结束）。
